package net.cubizor.gradle

import org.gradle.api.DefaultTask
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.repositories.ArtifactRepository
import org.gradle.api.artifacts.repositories.MavenArtifactRepository
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.plugins.JavaPluginExtension
import org.gradle.api.provider.ListProperty
import org.gradle.api.provider.MapProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.*
import org.gradle.kotlin.dsl.*
import java.io.File
import java.io.Serializable

abstract class PaperExtension {
    abstract val enabled: Property<Boolean>
    abstract val loaderPackage: Property<String>
    abstract val loaderClassName: Property<String>

    init {
        enabled.convention(false)
        loaderPackage.convention("net.cubizor.loader")
        loaderClassName.convention("AutoGeneratedPluginLoader")
    }
}

abstract class RuntimeDependencyExtension {
    abstract val outputDirectory: Property<String>
    abstract val organizeByGroup: Property<Boolean>

    init {
        outputDirectory.convention("runtime-dependencies")
        organizeByGroup.convention(true)
    }
}

data class DependencyInfo(
    val groupId: String,
    val artifactId: String,
    val version: String,
    val repository: RepositoryInfo
) : Serializable

data class RepositoryInfo(
    val name: String,
    val url: String,
    val usernameProperty: String? = null,
    val passwordProperty: String? = null,
    val isMavenCentral: Boolean = false
) : Serializable

abstract class RuntimeDependencyTask : DefaultTask() {
    @get:Input
    abstract val organizeByGroup: Property<Boolean>

    @get:InputFiles
    abstract val runtimeConfiguration: ConfigurableFileCollection

    @get:OutputDirectory
    abstract val outputDir: DirectoryProperty

    @TaskAction
    fun download() {
        val output = outputDir.get().asFile
        output.deleteRecursively()
        output.mkdirs()

        val organize = organizeByGroup.get()

        runtimeConfiguration.files.forEach { file ->
            val destFile = if (organize) {
                // artifact-version.jar formatinda ise artifact adina gore organize et
                val parts = file.nameWithoutExtension.split("-")
                val artifact = if (parts.size >= 2) {
                    parts.dropLast(1).joinToString("-")
                } else {
                    "unknown"
                }
                File(output, "$artifact/${file.name}")
            } else {
                File(output, file.name)
            }

            destFile.parentFile.mkdirs()
            file.copyTo(destFile, overwrite = true)
        }

        println("Runtime dependencies downloaded to: ${output.absolutePath}")

        // Indirilen dosyalari listele
        output.walkTopDown().filter { it.isFile }.forEach {
            println("  - ${it.relativeTo(output)}")
        }
    }
}

abstract class GeneratePaperLoaderTask : DefaultTask() {
    @get:Input
    abstract val loaderPackage: Property<String>

    @get:Input
    abstract val loaderClassName: Property<String>

    @get:Input
    abstract val dependencies: ListProperty<DependencyInfo>

    @get:Input
    abstract val repositories: MapProperty<String, RepositoryInfo>

    @get:OutputDirectory
    abstract val outputDir: DirectoryProperty

    @get:Internal
    abstract val resourcesDir: DirectoryProperty

    @TaskAction
    fun generate() {
        val packageName = loaderPackage.get()
        val className = loaderClassName.get()
        val deps = dependencies.get()
        val repos = repositories.get()

        // PluginLoader class'ini generate et
        val loaderClass = generateLoaderClass(packageName, className, deps, repos)

        // Java dosyasini yaz
        val packagePath = packageName.replace('.', '/')
        val outputFile = outputDir.get().asFile.resolve("$packagePath/$className.java")
        outputFile.parentFile.mkdirs()
        outputFile.writeText(loaderClass)

        println("Generated Paper PluginLoader: ${outputFile.absolutePath}")

        // plugin.yml veya paper-plugin.yml'i guncelle
        updatePluginYml(packageName, className)
    }

    private fun generateLoaderClass(
        packageName: String,
        className: String,
        deps: List<DependencyInfo>,
        repos: Map<String, RepositoryInfo>
    ): String {
        val repoMap = mutableMapOf<String, RepositoryInfo>()
        deps.forEach { dep ->
            // Maven Central'i skip et
            if (!dep.repository.isMavenCentral) {
                repoMap[dep.repository.name] = dep.repository
            }
        }

        val needsAuth = repoMap.values.any { it.usernameProperty != null || it.passwordProperty != null }
        val authImport = if (needsAuth) {
            "import org.eclipse.aether.util.repository.AuthenticationBuilder;"
        } else ""

        val repoCode = repoMap.values.distinctBy { it.url }.joinToString("\n") { repo ->
            val builderCode = StringBuilder()
            builderCode.append("        RemoteRepository.Builder ${repo.name}Builder = new RemoteRepository.Builder(\"${repo.name}\", \"default\", \"${repo.url}\");")

            if (repo.usernameProperty != null && repo.passwordProperty != null) {
                builderCode.append("\n")
                // Repository ID'den environment variable ismi olustur (ornek: myRepo -> MYREPO)
                val envPrefix = repo.name.uppercase().replace("-", "_").replace(".", "_")
                builderCode.append("        // Credentials - once environment variable, sonra system property'ye bak\n")
                builderCode.append("        String ${repo.name}User = System.getenv(\"${envPrefix}_USERNAME\");\n")
                builderCode.append("        if (${repo.name}User == null) {\n")
                builderCode.append("            ${repo.name}User = System.getProperty(\"${repo.usernameProperty}\");\n")
                builderCode.append("        }\n")
                builderCode.append("        String ${repo.name}Pass = System.getenv(\"${envPrefix}_PASSWORD\");\n")
                builderCode.append("        if (${repo.name}Pass == null) {\n")
                builderCode.append("            ${repo.name}Pass = System.getProperty(\"${repo.passwordProperty}\");\n")
                builderCode.append("        }\n")
                builderCode.append("        if (${repo.name}User != null && ${repo.name}Pass != null) {\n")
                builderCode.append("            ${repo.name}Builder.setAuthentication(new AuthenticationBuilder()\n")
                builderCode.append("                .addUsername(${repo.name}User)\n")
                builderCode.append("                .addPassword(${repo.name}Pass)\n")
                builderCode.append("                .build());\n")
                builderCode.append("        }\n")
            }

            builderCode.append("        resolver.addRepository(${repo.name}Builder.build());")
            builderCode.toString()
        }

        return """
package $packageName;

import io.papermc.paper.plugin.loader.PluginClasspathBuilder;
import io.papermc.paper.plugin.loader.PluginLoader;
import io.papermc.paper.plugin.loader.library.impl.MavenLibraryResolver;
import org.eclipse.aether.artifact.DefaultArtifact;
import org.eclipse.aether.graph.Dependency;
import org.eclipse.aether.repository.RemoteRepository;
$authImport
import org.jetbrains.annotations.NotNull;

public class $className implements PluginLoader {
    @Override
    public void classloader(@NotNull PluginClasspathBuilder classpathBuilder) {
        MavenLibraryResolver resolver = new MavenLibraryResolver();

${deps.joinToString("\n") { dep ->
        "        resolver.addDependency(new Dependency(new DefaultArtifact(\"${dep.groupId}:${dep.artifactId}:${dep.version}\"), null));"
}}

$repoCode

        classpathBuilder.addLibrary(resolver);
    }
}
""".trimIndent()
    }

    private fun updatePluginYml(packageName: String, className: String) {
        // plugin.yml veya paper-plugin.yml dosyasini bul
        val srcDir = resourcesDir.get().asFile
        val paperPluginYml = srcDir.resolve("paper-plugin.yml")
        val pluginYml = srcDir.resolve("plugin.yml")

        val targetFile = when {
            paperPluginYml.exists() -> paperPluginYml
            pluginYml.exists() -> pluginYml
            else -> {
                println("Warning: No plugin.yml or paper-plugin.yml found, skipping loader update")
                return
            }
        }

        // plugin.yml ise paper-plugin-loader:, paper-plugin.yml ise loader: kullan
        val isPaperPluginYml = targetFile.name == "paper-plugin.yml"
        val loaderKey = if (isPaperPluginYml) "loader:" else "paper-plugin-loader:"
        val loaderLine = "$loaderKey $packageName.$className"

        // Dosyayi oku
        val lines = targetFile.readLines().toMutableList()

        // Her iki key'i de kontrol et (eski veya yeni format)
        val loaderIndex = lines.indexOfFirst {
            it.trim().startsWith("loader:") || it.trim().startsWith("paper-plugin-loader:")
        }

        if (loaderIndex >= 0) {
            lines[loaderIndex] = loaderLine
        } else {
            // En basa ekle
            lines.add(0, loaderLine)
        }

        // Dosyayi yaz
        targetFile.writeText(lines.joinToString("\n"))
        println("Updated ${targetFile.name} with $loaderKey $packageName.$className")
    }
}

class RuntimeDependencyPlugin : Plugin<Project> {
    override fun apply(project: Project) {
        // Java plugin'i uygula (configurations icin gerekli)
        project.plugins.apply("java-library")

        // Extension olustur
        val extension = project.extensions.create("runtimeDependency", RuntimeDependencyExtension::class.java)
        val paperExtension = project.objects.newInstance(PaperExtension::class.java)

        // Paper'i nested extension olarak ekle
        (extension as org.gradle.api.plugins.ExtensionAware).extensions.add("paper", paperExtension)

        // Runtime download configuration olustur
        val runtimeDownload = project.configurations.create("runtimeDownload") {
            isCanBeConsumed = false
            isCanBeResolved = true
        }

        // Compile time'a da ekle
        project.configurations.named("implementation") {
            extendsFrom(runtimeDownload)
        }

        // Download ve organize task'i
        val downloadRuntimeDependencies = project.tasks.register("downloadRuntimeDependencies", RuntimeDependencyTask::class.java) {
            group = "runtime"
            description = "Downloads and organizes runtime dependencies"

            runtimeConfiguration.from(runtimeDownload)
            outputDir.set(project.layout.buildDirectory.dir(extension.outputDirectory))
            organizeByGroup.set(extension.organizeByGroup)
        }

        // Paper loader generation task'i
        val generatePaperLoader = project.tasks.register("generatePaperLoader", GeneratePaperLoaderTask::class.java) {
            group = "paper"
            description = "Generates Paper PluginLoader for runtime dependencies"

            loaderPackage.set(paperExtension.loaderPackage)
            loaderClassName.set(paperExtension.loaderClassName)
            outputDir.set(project.layout.buildDirectory.dir("generated/sources/paper-loader/java"))
            resourcesDir.set(project.layout.projectDirectory.dir("src/main/resources"))
        }

        // Repository credential detection ve Paper loader generation
        project.afterEvaluate {
            detectRepositoryCredentials(project)

            // Paper enabled ise loader'i generate et
            if (paperExtension.enabled.get()) {
                // Paper zaten dependency'leri yukluyor, downloadRuntimeDependencies'e gerek yok
                val deps = analyzeDependencies(project, runtimeDownload)
                val repos = collectRepositories(project)

                generatePaperLoader.configure {
                    dependencies.set(deps)
                    repositories.set(repos)
                }

                // compileJava, compileKotlin ve processResources'dan once calissin
                project.tasks.findByName("compileJava")?.dependsOn(generatePaperLoader)
                project.tasks.findByName("compileKotlin")?.dependsOn(generatePaperLoader)
                project.tasks.findByName("processResources")?.dependsOn(generatePaperLoader)

                // Generated source'u sourceSets'e ekle
                project.extensions.findByType(JavaPluginExtension::class.java)?.let { java ->
                    java.sourceSets.getByName("main").java.srcDir(
                        project.layout.buildDirectory.dir("generated/sources/paper-loader/java")
                    )
                }
            } else {
                // Paper disabled ise normal download task'ini build'e bagla
                project.tasks.named("build") {
                    dependsOn(downloadRuntimeDependencies)
                }
            }
        }
    }

    private fun analyzeDependencies(project: Project, configuration: Configuration): List<DependencyInfo> {
        val result = mutableListOf<DependencyInfo>()

        configuration.resolvedConfiguration.resolvedArtifacts.forEach { artifact ->
            val id = artifact.moduleVersion.id
            val repoInfo = findRepositoryForArtifact(project, id.group, id.name, id.version)

            result.add(
                DependencyInfo(
                    groupId = id.group,
                    artifactId = id.name,
                    version = id.version,
                    repository = repoInfo
                )
            )
        }

        return result
    }

    private fun findRepositoryForArtifact(
        project: Project,
        group: String,
        name: String,
        version: String
    ): RepositoryInfo {
        // Her repository'yi dene ve artifact'i bul
        val artifactPath = "${group.replace('.', '/')}/${name}/${version}/${name}-${version}.pom"

        for (repo in project.repositories) {
            if (repo is MavenArtifactRepository) {
                val repoUrl = repo.url.toString().removeSuffix("/")
                val repoName = repo.name.ifEmpty { "maven" }

                // Maven Central'i işaretle (Paper zaten sağlıyor ama dependency'yi kaydet)
                if (isMavenCentral(repoUrl)) {
                    return RepositoryInfo(
                        name = "MavenCentral",
                        url = repoUrl,
                        isMavenCentral = true
                    )
                }

                // Credential bilgilerini al
                val credentials = try {
                    repo.credentials
                } catch (e: Exception) {
                    null
                }

                val usernameProperty = if (credentials?.username != null) {
                    "${repoName}.username"
                } else null

                val passwordProperty = if (credentials?.password != null) {
                    "${repoName}.password"
                } else null

                return RepositoryInfo(
                    name = repoName,
                    url = repoUrl,
                    usernameProperty = usernameProperty,
                    passwordProperty = passwordProperty,
                    isMavenCentral = false
                )
            }
        }

        // Default: Maven Central (Paper tarafından sağlanıyor)
        return RepositoryInfo(
            name = "MavenCentral",
            url = "https://repo1.maven.org/maven2/",
            isMavenCentral = true
        )
    }

    private fun isMavenCentral(url: String): Boolean {
        val normalizedUrl = url.removeSuffix("/").lowercase()
        return normalizedUrl.contains("repo.maven.apache.org") ||
               normalizedUrl.contains("repo1.maven.org") ||
               normalizedUrl.contains("repo.maven.org")
    }

    private fun collectRepositories(project: Project): Map<String, RepositoryInfo> {
        val repos = mutableMapOf<String, RepositoryInfo>()

        for (repo in project.repositories) {
            if (repo is MavenArtifactRepository) {
                val repoUrl = repo.url.toString().removeSuffix("/")

                // Maven Central'i skip et (Paper zaten sağlıyor)
                if (isMavenCentral(repoUrl)) {
                    continue
                }

                val name = repo.name.ifEmpty { "maven-${repos.size}" }

                // Credential bilgilerini al
                val credentials = try {
                    repo.credentials
                } catch (e: Exception) {
                    null
                }

                val usernameProperty = if (credentials?.username != null) {
                    "${name}.username"
                } else null

                val passwordProperty = if (credentials?.password != null) {
                    "${name}.password"
                } else null

                repos[name] = RepositoryInfo(
                    name = name,
                    url = repoUrl,
                    usernameProperty = usernameProperty,
                    passwordProperty = passwordProperty
                )
            }
        }

        // Not: Maven Central eklenmez, Paper tarafından zaten sağlanıyor
        return repos
    }

    private fun detectRepositoryCredentials(project: Project) {
        project.repositories.withType<MavenArtifactRepository> {
            // gradle.properties veya environment variable'lardan credential al
            if (url.scheme in listOf("http", "https")) {
                val user = project.findProperty("${name}.username")?.toString()
                    ?: System.getenv("${name.uppercase()}_USERNAME")
                val pass = project.findProperty("${name}.password")?.toString()
                    ?: System.getenv("${name.uppercase()}_PASSWORD")

                // Sadece hem username hem password varsa credential ekle
                if (user != null && pass != null) {
                    credentials {
                        username = user
                        password = pass
                    }
                }
            }
        }
    }
}
