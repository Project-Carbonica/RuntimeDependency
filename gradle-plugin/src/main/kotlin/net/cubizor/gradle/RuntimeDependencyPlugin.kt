package net.cubizor.gradle

import org.gradle.api.DefaultTask
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.repositories.ArtifactRepository
import org.gradle.api.artifacts.repositories.MavenArtifactRepository
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.plugins.JavaPluginExtension
import org.gradle.api.provider.ListProperty
import org.gradle.api.provider.MapProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.*
import org.gradle.kotlin.dsl.*
import java.io.File
import java.io.Serializable

abstract class PaperExtension {
    abstract val enabled: Property<Boolean>
    abstract val loaderPackage: Property<String>
    abstract val loaderClassName: Property<String>

    init {
        enabled.convention(false)
        loaderPackage.convention("net.cubizor.loader")
        loaderClassName.convention("AutoGeneratedPluginLoader")
    }
}

abstract class RuntimeDependencyExtension {
    abstract val outputDirectory: Property<String>
    abstract val organizeByGroup: Property<Boolean>

    init {
        outputDirectory.convention("runtime-dependencies")
        organizeByGroup.convention(true)
    }
}

data class DependencyInfo(
    val groupId: String,
    val artifactId: String,
    val version: String,
    val repository: RepositoryInfo
) : Serializable

data class RepositoryInfo(
    val name: String,
    val url: String
) : Serializable

abstract class RuntimeDependencyTask : DefaultTask() {
    @get:Input
    abstract val organizeByGroup: Property<Boolean>

    @get:InputFiles
    abstract val runtimeConfiguration: ConfigurableFileCollection

    @get:OutputDirectory
    abstract val outputDir: DirectoryProperty

    @TaskAction
    fun download() {
        val output = outputDir.get().asFile
        output.deleteRecursively()
        output.mkdirs()

        val organize = organizeByGroup.get()

        runtimeConfiguration.files.forEach { file ->
            val destFile = if (organize) {
                // artifact-version.jar formatinda ise artifact adina gore organize et
                val parts = file.nameWithoutExtension.split("-")
                val artifact = if (parts.size >= 2) {
                    parts.dropLast(1).joinToString("-")
                } else {
                    "unknown"
                }
                File(output, "$artifact/${file.name}")
            } else {
                File(output, file.name)
            }

            destFile.parentFile.mkdirs()
            file.copyTo(destFile, overwrite = true)
        }

        println("Runtime dependencies downloaded to: ${output.absolutePath}")

        // Indirilen dosyalari listele
        output.walkTopDown().filter { it.isFile }.forEach {
            println("  - ${it.relativeTo(output)}")
        }
    }
}

abstract class GeneratePaperLoaderTask : DefaultTask() {
    @get:Input
    abstract val loaderPackage: Property<String>

    @get:Input
    abstract val loaderClassName: Property<String>

    @get:Input
    abstract val dependencies: ListProperty<DependencyInfo>

    @get:Input
    abstract val repositories: MapProperty<String, RepositoryInfo>

    @get:OutputDirectory
    abstract val outputDir: DirectoryProperty

    @get:Internal
    abstract val resourcesDir: DirectoryProperty

    @TaskAction
    fun generate() {
        val packageName = loaderPackage.get()
        val className = loaderClassName.get()
        val deps = dependencies.get()
        val repos = repositories.get()

        // PluginLoader class'ini generate et
        val loaderClass = generateLoaderClass(packageName, className, deps, repos)

        // Java dosyasini yaz
        val packagePath = packageName.replace('.', '/')
        val outputFile = outputDir.get().asFile.resolve("$packagePath/$className.java")
        outputFile.parentFile.mkdirs()
        outputFile.writeText(loaderClass)

        println("Generated Paper PluginLoader: ${outputFile.absolutePath}")

        // plugin.yml veya paper-plugin.yml'i guncelle
        updatePluginYml(packageName, className)
    }

    private fun generateLoaderClass(
        packageName: String,
        className: String,
        deps: List<DependencyInfo>,
        repos: Map<String, RepositoryInfo>
    ): String {
        val repoMap = mutableMapOf<String, RepositoryInfo>()
        deps.forEach { dep ->
            repoMap[dep.repository.name] = dep.repository
        }

        return """
package $packageName;

import io.papermc.paper.plugin.loader.PluginClasspathBuilder;
import io.papermc.paper.plugin.loader.PluginLoader;
import io.papermc.paper.plugin.loader.library.impl.MavenLibraryResolver;
import org.eclipse.aether.artifact.DefaultArtifact;
import org.eclipse.aether.graph.Dependency;
import org.eclipse.aether.repository.RemoteRepository;
import org.jetbrains.annotations.NotNull;

public class $className implements PluginLoader {
    @Override
    public void classloader(@NotNull PluginClasspathBuilder classpathBuilder) {
        MavenLibraryResolver resolver = new MavenLibraryResolver();

${deps.joinToString("\n") { dep ->
        "        resolver.addDependency(new Dependency(new DefaultArtifact(\"${dep.groupId}:${dep.artifactId}:${dep.version}\"), null));"
}}

${repoMap.values.distinctBy { it.url }.joinToString("\n") { repo ->
        "        resolver.addRepository(new RemoteRepository.Builder(\"${repo.name}\", \"default\", \"${repo.url}\").build());"
}}

        classpathBuilder.addLibrary(resolver);
    }
}
""".trimIndent()
    }

    private fun updatePluginYml(packageName: String, className: String) {
        // plugin.yml veya paper-plugin.yml dosyasini bul
        val srcDir = resourcesDir.get().asFile
        val paperPluginYml = srcDir.resolve("paper-plugin.yml")
        val pluginYml = srcDir.resolve("plugin.yml")

        val targetFile = when {
            paperPluginYml.exists() -> paperPluginYml
            pluginYml.exists() -> pluginYml
            else -> {
                println("Warning: No plugin.yml or paper-plugin.yml found, skipping loader update")
                return
            }
        }

        // Dosyayi oku
        val lines = targetFile.readLines().toMutableList()
        val loaderLine = "loader: $packageName.$className"

        // loader: satırını bul ve guncelle veya ekle
        val loaderIndex = lines.indexOfFirst { it.trim().startsWith("loader:") }
        if (loaderIndex >= 0) {
            lines[loaderIndex] = loaderLine
        } else {
            // En basa ekle
            lines.add(0, loaderLine)
        }

        // Dosyayi yaz
        targetFile.writeText(lines.joinToString("\n"))
        println("Updated ${targetFile.name} with loader: $packageName.$className")
    }
}

class RuntimeDependencyPlugin : Plugin<Project> {
    override fun apply(project: Project) {
        // Java plugin'i uygula (configurations icin gerekli)
        project.plugins.apply("java-library")

        // Extension olustur
        val extension = project.extensions.create("runtimeDependency", RuntimeDependencyExtension::class.java)
        val paperExtension = project.objects.newInstance(PaperExtension::class.java)

        // Paper'i nested extension olarak ekle
        (extension as org.gradle.api.plugins.ExtensionAware).extensions.add("paper", paperExtension)

        // Runtime download configuration olustur
        val runtimeDownload = project.configurations.create("runtimeDownload") {
            isCanBeConsumed = false
            isCanBeResolved = true
        }

        // Compile time'a da ekle
        project.configurations.named("implementation") {
            extendsFrom(runtimeDownload)
        }

        // Download ve organize task'i
        val downloadRuntimeDependencies = project.tasks.register("downloadRuntimeDependencies", RuntimeDependencyTask::class.java) {
            group = "runtime"
            description = "Downloads and organizes runtime dependencies"

            runtimeConfiguration.from(runtimeDownload)
            outputDir.set(project.layout.buildDirectory.dir(extension.outputDirectory))
            organizeByGroup.set(extension.organizeByGroup)
        }

        // Paper loader generation task'i
        val generatePaperLoader = project.tasks.register("generatePaperLoader", GeneratePaperLoaderTask::class.java) {
            group = "paper"
            description = "Generates Paper PluginLoader for runtime dependencies"

            loaderPackage.set(paperExtension.loaderPackage)
            loaderClassName.set(paperExtension.loaderClassName)
            outputDir.set(project.layout.buildDirectory.dir("generated/sources/paper-loader/java"))
            resourcesDir.set(project.layout.projectDirectory.dir("src/main/resources"))
        }

        // Repository credential detection ve Paper loader generation
        project.afterEvaluate {
            detectRepositoryCredentials(project)

            // Paper enabled ise loader'i generate et
            if (paperExtension.enabled.get()) {
                // Paper zaten dependency'leri yukluyor, downloadRuntimeDependencies'e gerek yok
                val deps = analyzeDependencies(project, runtimeDownload)
                val repos = collectRepositories(project)

                generatePaperLoader.configure {
                    dependencies.set(deps)
                    repositories.set(repos)
                }

                // compileJava ve compileKotlin'den once calissin
                project.tasks.findByName("compileJava")?.dependsOn(generatePaperLoader)
                project.tasks.findByName("compileKotlin")?.dependsOn(generatePaperLoader)

                // Generated source'u sourceSets'e ekle
                project.extensions.findByType(JavaPluginExtension::class.java)?.let { java ->
                    java.sourceSets.getByName("main").java.srcDir(
                        project.layout.buildDirectory.dir("generated/sources/paper-loader/java")
                    )
                }
            } else {
                // Paper disabled ise normal download task'ini build'e bagla
                project.tasks.named("build") {
                    dependsOn(downloadRuntimeDependencies)
                }
            }
        }
    }

    private fun analyzeDependencies(project: Project, configuration: Configuration): List<DependencyInfo> {
        val result = mutableListOf<DependencyInfo>()

        configuration.resolvedConfiguration.resolvedArtifacts.forEach { artifact ->
            val id = artifact.moduleVersion.id
            val repoInfo = findRepositoryForArtifact(project, id.group, id.name, id.version)

            if (repoInfo != null) {
                result.add(
                    DependencyInfo(
                        groupId = id.group,
                        artifactId = id.name,
                        version = id.version,
                        repository = repoInfo
                    )
                )
            }
        }

        return result
    }

    private fun findRepositoryForArtifact(
        project: Project,
        group: String,
        name: String,
        version: String
    ): RepositoryInfo? {
        // Bilinen repository'leri tara
        for (repo in project.repositories) {
            if (repo is MavenArtifactRepository) {
                val repoName = repo.name.ifEmpty { "maven" }
                val repoUrl = repo.url.toString()

                // Basit heuristic: ilk Maven repository'yi kullan
                return RepositoryInfo(
                    name = repoName,
                    url = repoUrl
                )
            }
        }

        // Default: Maven Central
        return RepositoryInfo("central", "https://repo1.maven.org/maven2/")
    }

    private fun collectRepositories(project: Project): Map<String, RepositoryInfo> {
        val repos = mutableMapOf<String, RepositoryInfo>()

        for (repo in project.repositories) {
            if (repo is MavenArtifactRepository) {
                val name = repo.name.ifEmpty { "maven-${repos.size}" }
                repos[name] = RepositoryInfo(
                    name = name,
                    url = repo.url.toString()
                )
            }
        }

        // En azindan Maven Central ekle
        if (repos.isEmpty()) {
            repos["central"] = RepositoryInfo("central", "https://repo1.maven.org/maven2/")
        }

        return repos
    }

    private fun detectRepositoryCredentials(project: Project) {
        project.repositories.withType<MavenArtifactRepository> {
            // gradle.properties veya environment variable'lardan credential al
            if (url.scheme in listOf("http", "https")) {
                val user = project.findProperty("${name}.username")?.toString()
                    ?: System.getenv("${name.uppercase()}_USERNAME")
                val pass = project.findProperty("${name}.password")?.toString()
                    ?: System.getenv("${name.uppercase()}_PASSWORD")

                // Sadece hem username hem password varsa credential ekle
                if (user != null && pass != null) {
                    credentials {
                        username = user
                        password = pass
                    }
                }
            }
        }
    }
}
